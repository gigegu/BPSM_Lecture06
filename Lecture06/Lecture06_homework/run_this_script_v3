#!/usr/bin/bash

inputfile="$PWD/blastoutput2.out"

rm -f *.exercise.out

#count the number of non-comment lines in the inputfile
goodlines=$(grep -v "#" ${inputfile} | wc -l | cut -d ' ' -f1)
#unset the internal field separator
unset IFS
#if the variable dataline exists, clear it so that it starts empty
unset dataline
#initialise the variables shortHSP and hspcounter to 0 so that they can be used later in the script to count or track specific conditions
shortHSP=0;
hspcounter=0;
#print the number of goodlines you have for processing
echo -e "We have ${goodlines} data lines for processing...\n"

#initialise a bash array for multiple HSPs, call it dupS_acc
dupS_acc=()

#assign some variables with integer values that represent thresholds/cutoffs for different groups
group1cut=150
group2cut=250
group3cut=350

#create new variables to store the output based on the previously defined thresholds
outfile1="HSPscore.${group1cut}.exercise.out"
outfile2="HSPscore.${group2cut}.exercise.out"
outfile3="HSPscore.${group3cut}.exercise.out"
outfile4="HSPscore.morethan.${group3cut}.exercise.out"

#remove previous versions of the output files
rm -f ${outfile1} ${outfile2} ${outfile3} ${outfile4}

while read wholeline
do
	echo "Line is ${wholeline}"

#get rid of input ines that start with '#'
	if [ ${wholeline: 0:1} != '#' ]
	then
		dataline=$((dataline+1))
#echo "Line ${dataline} starts with ${wholeline:0:1}"

#split the line into the fields we want
		read Q_acc S_acc pc_identity alignment_length mismatches gap_opens Q_start Q_end S_start S_end evalue bitscore <<< ${wholeline}

#make sure that ${bitscore is a full number and not a float
		bitscore=$(printf "%0f\n" "${bitscore}")

#list the subject accession for all HSPs
		echo -e "${dataline}\t${Q_acc}\t${S_acc}" >> Subject_acessions.exercise.out

#List the alignment length and percent ID for all HSPs
		echo -e "${dataline}\t${alignment_length}\t${pc_identity}" >> al_leng_pcID.exercise.out

#show the HSPs with more than 20 mismatches
		if [ ${mismatches} -gt 20 ] 
		then
			echo -e "${dataline}\tmore than 20 mismatches:\t${Q_acc} ${S_acc} ${mismatches}"
		fi   

#show the HSPs shorter than 100 amino acids and with more than 20 mismatches
		if [ ${alignment_length} -lt 100 ] && [ ${mismatches} -gt 20 ]
 		then
			echo -e "${dataline}\tHSP shorter than 100aa, more \
      than 20 mismatches:\t${alignment_length}\t${mismatches}"
		fi

#list the first 20 HSPs that have fewer than 20 mismatches
		if [ ${mismatches} -lt 20 ] 
 		then
 			hspcounter=$((hspcounter+1))
 			if [ ${hspcounter} -le 20 ]
  			then
	  			hsp_array+=("${wholeline}")
				echo -e "${dataline}\t${hspcounter}\t${wholeline}" >> Fewer.than20MM.exercise.out
 			fi
		fi

#check how many HSPs are shorter than 100 amino acids
		if [ ${alignment_length} -lt 100 ] 
 		then
			shortHSP=$((shortHSP+1))
		fi

#list the top ten highest (best) HSPs
		if [ ${dataline} -le 10 ]
 		then
			echo -e "${dataline}\t${wholeline}" >> Top10.HSPs.exercise.out
		fi

#list the start positions of all matches where the HSP Subject accession includes the letters string AEI
		if [[ ${S_acc} == *"AEI"* ]]; then
 			echo -e "${dataline}\t${S_acc} contains AEI: \
    Subject starts at ${S_start}, Query starts at ${Q_start}" \
    >> AEIinSubjectAcc.starts.exercise.out 
		fi     

#how many subject sequences have more than once HSP?
		if [[ ${S_acc} == ${pre_acc} ]]
 		then
 			dupecount=$((dupecount+1))
 			if [[ ${dupecount} == 1 ]]; then
  				dupS_acc=${S_acc}
 			fi

#check to see is some subjects have more than two HSPs
 			if [[ $dupS_acc == *${S_acc}* ]]; then
  				echo ""
  			else
  				dupS_acc+=(${S_acc})
 			fi

		fi

		pre_acc=${S_acc}

#check to see what percentage of each HSP consists of mismatches. rounded numbers only.
		MMpercent=$((100*${mismatches}/${alignment_length}))
		echo -e "${dataline}\t${alignment_length}\t${mismatches}\t${MMpercent}" \
   >> Mismatchpercent.exercise.out

#allocate HSPs into different groups based on their scores
		scorebin=1
		if [ ${bitscore} -gt ${group3cut} ]; then 
     			scorebin=4
		fi
		if [ ${bitscore} -le ${group3cut} ] && [ ${bitscore} -gt ${group2cut} ]; then 
     			scorebin=3
		fi
		if [ ${bitscore} -le ${group2cut} ] && [ ${bitscore} -gt ${group1cut} ]; then 
     			scorebin=2
		fi

#use a case statement to send the output to the relevant file
		scoregroupdetails=$(echo -e "${dataline}\t${Q_acc}\t${S_acc}\t${bitscore}")
		case $scorebin in
		       	4) 
				echo -e "${scoregroupdetails}" >> ${outfile4}
				;;
			3) 
    				echo -e "${scoregroupdetails}" >> ${outfile3}
    				;;
  			2) 
    				echo -e "${scoregroupdetails}" >> ${outfile2}
    				;;
  			1) 
  				 echo -e "${scoregroupdetails}" >> ${outfile1}
    				;;
		esac

	fi
done < ${inputfile}

 echo -e "\n\nENDBLOCK\n\nThere were ${shortHSP} HSPs shorter than 100 amino acids"
 echo -e "There were ${#dupS_acc[@]} Subjects with multiple HSPs"
